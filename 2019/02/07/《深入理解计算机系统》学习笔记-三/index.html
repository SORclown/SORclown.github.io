<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      《深入理解计算机系统》学习笔记-三 | Hexo 
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
      <meta name="author" content="John Doe">
    
    

    <meta name="description" content="2.1.7 C语言中的位级运算1.C语言支持按位布尔运算。2.确定位级表达式的结果最好的方法，就是将十六进制的参数扩展成二进制表示并执行二进制运算，然后再转换回十六进制。 2.1.8 C语言中的逻辑运算逻辑运算与位级运算的区别 逻辑运算认为所有非零的参数都表示TRUE,参数0表示FALSE.它们返回1或者0，分别表示结果为TURE或者为FALSE.按位运算只有在特殊情况下，也就是参数被限制为0或者">
<meta property="og:type" content="article">
<meta property="og:title" content="《深入理解计算机系统》学习笔记-三 | Hexo">
<meta property="og:url" content="http://yoursite.com/2019/02/07/《深入理解计算机系统》学习笔记-三/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="2.1.7 C语言中的位级运算1.C语言支持按位布尔运算。2.确定位级表达式的结果最好的方法，就是将十六进制的参数扩展成二进制表示并执行二进制运算，然后再转换回十六进制。 2.1.8 C语言中的逻辑运算逻辑运算与位级运算的区别 逻辑运算认为所有非零的参数都表示TRUE,参数0表示FALSE.它们返回1或者0，分别表示结果为TURE或者为FALSE.按位运算只有在特殊情况下，也就是参数被限制为0或者">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://i.loli.net/2019/02/08/5c5cf73d87a1b.png">
<meta property="og:image" content="en-resource://database/1025:1">
<meta property="og:updated_time" content="2019-02-08T03:29:09.267Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《深入理解计算机系统》学习笔记-三 | Hexo">
<meta name="twitter:description" content="2.1.7 C语言中的位级运算1.C语言支持按位布尔运算。2.确定位级表达式的结果最好的方法，就是将十六进制的参数扩展成二进制表示并执行二进制运算，然后再转换回十六进制。 2.1.8 C语言中的逻辑运算逻辑运算与位级运算的区别 逻辑运算认为所有非零的参数都表示TRUE,参数0表示FALSE.它们返回1或者0，分别表示结果为TURE或者为FALSE.按位运算只有在特殊情况下，也就是参数被限制为0或者">
<meta name="twitter:image" content="https://i.loli.net/2019/02/08/5c5cf73d87a1b.png">
    
    
    
      <link rel="icon" type="image/x-icon" href="/favicon.png">
    
    <link rel="stylesheet" href="/css/uno.css">
    <link rel="stylesheet" href="/css/highlight.css">
    <link rel="stylesheet" href="/css/archive.css">
    <link rel="stylesheet" href="/css/china-social-icon.css">

</head>
<body>

    <span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

    

<header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">

  
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">Hexo</a></h1>
        <hr class="panel-cover__divider">

        

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">首页</a></li>
              
                
                <li class="navigation__item"><a href="/about" title="" class="">关于</a></li>
              
                
                <li class="navigation__item"><a href="/archive" title="" class="">归档</a></li>
              

            </ul>
          </nav>

          <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->



        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            

<article class="post-container post-container--single">

  <header class="post-header">
    
    <h1 class="post-title">《深入理解计算机系统》学习笔记-三</h1>

    

    <div class="post-meta">
      <time datetime="2019-02-07" class="post-meta__date date">2019-02-07</time> 

      <span class="post-meta__tags tags">

          

          

      </span>
    </div>
    
    

  </header>

  <section id="post-content" class="article-content post">
    <h3 id="2-1-7-C语言中的位级运算"><a href="#2-1-7-C语言中的位级运算" class="headerlink" title="2.1.7 C语言中的位级运算"></a>2.1.7 C语言中的位级运算</h3><p>1.C语言支持按位布尔运算。<br>2.确定位级表达式的结果最好的方法，就是将十六进制的参数扩展成二进制表示并执行二进制运算，然后再转换回十六进制。</p>
<h3 id="2-1-8-C语言中的逻辑运算"><a href="#2-1-8-C语言中的逻辑运算" class="headerlink" title="2.1.8 C语言中的逻辑运算"></a>2.1.8 C语言中的逻辑运算</h3><h4 id="逻辑运算与位级运算的区别"><a href="#逻辑运算与位级运算的区别" class="headerlink" title="逻辑运算与位级运算的区别"></a>逻辑运算与位级运算的区别</h4><ol>
<li><p>逻辑运算认为所有非零的参数都表示TRUE,参数0表示FALSE.它们返回1或者0，分别表示结果为TURE或者为FALSE.<br>按位运算只有在特殊情况下，也就是参数被限制为0或者1时，才和与其对应的逻辑运算有相同的行为。</p>
<ol start="2">
<li>逻辑运算符&amp;&amp;和||与对应的位级运算&amp;和|之间的第二个重要的区别是，如果对第一个参数求值就能确定表达式的结果，那么逻辑运算符就不会对第二个参数求值。</li>
</ol>
<h3 id="2-1-9-C语言中的位移运算"><a href="#2-1-9-C语言中的位移运算" class="headerlink" title="2.1.9 C语言中的位移运算"></a>2.1.9 C语言中的位移运算</h3><p>C语言提供了一组位移运算，向左或者向右移动位模式。<br>对于一个位表示为[X w-1,X w-2,…,X 0]的操作数x，C表达式x&lt;&lt;k会生成一个值，其位表示为[X w-k-1, X w-k-2,…, X 0,…,0],x向左移动K位， 丢弃最高的K位， 并在右端补k个0。<br>位移量应该是一个 0  – w-1 之间的值。 移位运算是从左至右可结合的， 所以x&lt;&lt;j&lt;&lt;k等价于(x«j)«k。<br>C语言标准并没有明确定义对千有符号数应该使用哪种类型的右移——算术右移或者逻辑右移都可以。 不幸地， 这就意味着任何假设一种或者另一种右移形式的代码都可能会遇到可移植性问题。<br>然而， 实际上， 几乎所有的编译器／机器组合都对 <em>有符号数</em> 使用算术右移， 且许多程序员也都假设机器会使用这种右移。另一方面，对于 <em>无符号数</em> ，右移必须是逻辑的。<br>Java对于如何进行右移有明确的定义。表达是x&gt;&gt;k会将x算术右移k个位置，而x&gt;&gt;&gt;k会对x做逻辑右移。</p>
</li>
</ol>
<h3 id="2-2-1-整型数据类型"><a href="#2-2-1-整型数据类型" class="headerlink" title="2.2.1 整型数据类型"></a>2.2.1 整型数据类型</h3><ul>
<li>C 语言支持多种整型数据类型——表示有限范围的整数。<br>每种类型都能用关键字来指定大小， 这些关键字包括 <strong>char、 short 、 long</strong>, 同时还可以指示被表示的数字是非负数 （声明为 <strong>unsigned</strong>), 或者可能是负数（<strong>默认</strong>）。<br>为这些不同的大小分配的字节数根据程序编译为 32 位还是 64 位而有所不同。 根据字节分配， 不同的大小所能表示的值的范围是不同的。<br>这里给出来的<strong>唯一一个</strong>与机器相关的取值范围是大小指示符 <strong>long</strong>的。 大多数 <strong>64 位</strong>机器使用 8 个字节的表示， <strong>32 位</strong>机器上使用的 4 个字节表示。<br>一个很值得注意的特点是取值范围不是对称的负数的范围比整数的范围大1。<br>C 语言标准定义了每种数据类型必须能够表示的最小的取值范围。<br>C和C++都支持有符号（默认）和无符号数。 Java 只支持有符号数。</li>
</ul>
<h3 id="2-2-2-无符号数的编码"><a href="#2-2-2-无符号数的编码" class="headerlink" title="2.2.2 无符号数的编码"></a>2.2.2 无符号数的编码</h3><p>原理：无符号数编码的定义<br>对向量x= [X w-I, X w-2, …, X 0]<br>在这个编码中，每个位x, 都取值为0或1, 后一种取值意味着数值 z; 应 为数字值的一部分。我们用一个函数B2队(Binary to Uns igned的缩写，长度为w)来表示：<img src="https://i.loli.net/2019/02/08/5c5cf73d87a1b.png" alt="image"><br>原理：无符号数编码的唯一性<br>函数B2U w 是一个双射。<br>数学术语双射是指一个函数f有两面：它将数值x映射为数值y, 即y=f(x），但它将数值x映射为数值y，即y=f(x),但它也可以反向操作，因为对每一个y而言，都有唯一一个数值x使得f(x)=y。这可以用反函数f^(-1)来表示。<br>在本例中，即x=f^(-1)(y))。函数B2U w 将每一个长度为w的位向量都映射为 0~2^w -1之间的一个唯一值；反过来，我们称其为U2B w（即“无符号数到二进制”), 在0~2^w -1之间的每一个整数都可以映射一个唯一的长度为 w 的位模式。</p>
<h3 id="2-2-3-补码编码"><a href="#2-2-3-补码编码" class="headerlink" title="2.2.3 补码编码"></a>2.2.3 补码编码</h3><ul>
<li>最常见的有符号数的计算机表示方式就是补码(two’s-complement)形式。</li>
</ul>
<p>B2T4([1111])=-1<em> 2^3+1</em> 2^2+1<em> 2^1+1</em> 2^0=-1</p>
<h5 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h5><ol>
<li>补码的范围是不对称的：<br>| TMin I = I TMax I + 1， 也就是说， TMin没有与之对应的正数。</li>
<li>第二， 最大的无符号数值刚好比补码的最大值的两倍大一点： UMaxw =2TMaxw 十1。<br>补码表示中所有表示负数的位模式在无符号表示中都变成了正数。</li>
</ol>
<p>C语言标准并没有要求要用 <em>补码</em> 形式来表示有符号整数， 但是几乎所有的机器都是这么做的。 所以，如果希望代码具有最大的 <em>可移植性</em> ，能够在所有可能的机器上运行，那么除了<img src="en-resource://database/1025:1" alt="73508aa6c408b7cd08f4726473ac8f29.png"><br>所示的那些范围之外， 我们不应该假设任何可表示的数值范围， 也不应该假设有符号数会使用何种特殊的表示方式。<br>另一方面， 许多程序的书写都假设用补码来表示有符号数，并且具有“典型的” 取值范围， 这些程序也能够在大量的机器和编译器上移植。 C库中的文件<strong>＜limtis.h&gt;</strong> 定义了一组常量， 来限定编译器运行的这台机器的不同整型数据类型的取值范围。</p>
<p>最小值 -2^(w-1)<br>最大值 2^(w-1)-1</p>
<ul>
<li>原理： 补码编码的唯一性<br>函数B2T w是一个双射。<br>我们定义函数T2B w（即 “补码到二进制”)作为B2T w的反函数。 也就是说， 对于每个数x, 满足<em>TMin w&lt;=x&lt;=TMax w</em>， 则T2B w(x)是x 的（唯一的）w位模式。</li>
</ul>
<h5 id="关于确定大小的整数类型的更多内容"><a href="#关于确定大小的整数类型的更多内容" class="headerlink" title="关于确定大小的整数类型的更多内容"></a>关于确定大小的整数类型的更多内容</h5><p>ISO C99标准在文件 <strong>stdint.h</strong> 中引入了这个整数类型类。这 个文件定义了一组数据类型，它们的声明形如intN_t和uintN_t, 对不同的N值指定N位有符号和无符号整数(大多为8、16、32、64）。<br>这些数据类型对应着一组宏，定义了每个N的值对应的最小和最大值。形如：INTN_MIN、INTN_MAX和UINTN_MAX。<br>当C预处理器遇到仅用空格（或其他空白宇符）分隔的一个字符串常量序列时， 就把它们串联起来。 </p>
<h6 id="java"><a href="#java" class="headerlink" title="java"></a>java</h6><p>java 标准：要求采用补码表示，取值范围与64位情况一样。在Java中，单字节数据类型称为byte,（C语言中为char).</p>
<h6 id="有符号数的其他表示方法"><a href="#有符号数的其他表示方法" class="headerlink" title="有符号数的其他表示方法"></a>有符号数的其他表示方法</h6><p><strong>反码</strong>（Ones’Complement):除了最高有效位的权是 <strong>-（2^(w-1)-1)</strong> 而不是 <strong>-2^(w-1)</strong>, 与补码一样。<br><strong>原码</strong>（Sign-Magnitude):最高有效位是符号位，用来确定剩下的位应该取负权还是正权。</p>

  </section>

  <section class="post-comments">

    <!-- 将评论系统（例如Disqus、多说、友言、畅言等）提供的代码片段粘贴在这里 -->
    
</section>


</article>


            <footer class="footer">

    <span class="footer__copyright">&copy; 2014-2015. | 由<a href="https://hexo.io/">Hexo</a>强力驱动 | 主题<a href="https://github.com/someus/huno">Huno</a></span>
    
</footer>
        </div>
    </div>

    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>
    

    

    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript"> 
        $(document).ready(function(){
            MathJax.Hub.Config({ 
                tex2jax: {inlineMath: [['[latex]','[/latex]'], ['\\(','\\)']]} 
            });
        });
    </script>


    

    <script src="/js/jquery.min.js"></script>
    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    
    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

</body>
</html>
