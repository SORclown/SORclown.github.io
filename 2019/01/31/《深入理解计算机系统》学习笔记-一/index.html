<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      《深入理解计算机系统》学习笔记(一) | Hexo 
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
      <meta name="author" content="John Doe">
    
    

    <meta name="description" content="第一章 计算机系统漫游1.1 信息就是位+上下文 源程序由值0和1组成的位（比特）序列，8个位为一组（字节）。 在不同的上下文中，一个同样的字节序列可能表示一个整数，浮点数，字符串或者叫机器指令。1.2 hello.c -&amp;gt;（预处理阶段）hello.i -&amp;gt;（编译阶段）hello.s[汇编语言程序] -&amp;gt;[（汇编阶段）翻译成机器语言指令,并将其打包为可重定位目标程序（reloca">
<meta property="og:type" content="article">
<meta property="og:title" content="《深入理解计算机系统》学习笔记(一) | Hexo">
<meta property="og:url" content="http://yoursite.com/2019/01/31/《深入理解计算机系统》学习笔记-一/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="第一章 计算机系统漫游1.1 信息就是位+上下文 源程序由值0和1组成的位（比特）序列，8个位为一组（字节）。 在不同的上下文中，一个同样的字节序列可能表示一个整数，浮点数，字符串或者叫机器指令。1.2 hello.c -&amp;gt;（预处理阶段）hello.i -&amp;gt;（编译阶段）hello.s[汇编语言程序] -&amp;gt;[（汇编阶段）翻译成机器语言指令,并将其打包为可重定位目标程序（reloca">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-01-31T10:54:11.166Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《深入理解计算机系统》学习笔记(一) | Hexo">
<meta name="twitter:description" content="第一章 计算机系统漫游1.1 信息就是位+上下文 源程序由值0和1组成的位（比特）序列，8个位为一组（字节）。 在不同的上下文中，一个同样的字节序列可能表示一个整数，浮点数，字符串或者叫机器指令。1.2 hello.c -&amp;gt;（预处理阶段）hello.i -&amp;gt;（编译阶段）hello.s[汇编语言程序] -&amp;gt;[（汇编阶段）翻译成机器语言指令,并将其打包为可重定位目标程序（reloca">
    
    
    
      <link rel="icon" type="image/x-icon" href="/favicon.png">
    
    <link rel="stylesheet" href="/css/uno.css">
    <link rel="stylesheet" href="/css/highlight.css">
    <link rel="stylesheet" href="/css/archive.css">
    <link rel="stylesheet" href="/css/china-social-icon.css">

</head>
<body>

    <span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

    

<header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">

  
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">Hexo</a></h1>
        <hr class="panel-cover__divider">

        

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">首页</a></li>
              
                
                <li class="navigation__item"><a href="/about" title="" class="">关于</a></li>
              
                
                <li class="navigation__item"><a href="/archive" title="" class="">归档</a></li>
              

            </ul>
          </nav>

          <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->



        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            

<article class="post-container post-container--single">

  <header class="post-header">
    
    <h1 class="post-title">《深入理解计算机系统》学习笔记(一)</h1>

    

    <div class="post-meta">
      <time datetime="2019-01-31" class="post-meta__date date">2019-01-31</time> 

      <span class="post-meta__tags tags">

          

          

      </span>
    </div>
    
    

  </header>

  <section id="post-content" class="article-content post">
    <h1 id="第一章-计算机系统漫游"><a href="#第一章-计算机系统漫游" class="headerlink" title="第一章 计算机系统漫游"></a>第一章 计算机系统漫游</h1><h2 id="1-1-信息就是位-上下文"><a href="#1-1-信息就是位-上下文" class="headerlink" title="1.1 信息就是位+上下文"></a>1.1 信息就是位+上下文</h2><ul>
<li>源程序由值0和1组成的位（比特）序列，8个位为一组（字节）。</li>
<li>在不同的上下文中，一个同样的字节序列可能表示一个整数，浮点数，字符串或者叫机器指令。<h2 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h2></li>
<li>hello.c</li>
<li>-&gt;（预处理阶段）hello.i</li>
<li>-&gt;（编译阶段）hello.s[汇编语言程序]</li>
<li>-&gt;[（汇编阶段）翻译成机器语言指令,并将其打包为可重定位目标程序（relocatable object program）]hello.o</li>
<li>-&gt;（链接阶段）hello<h2 id="1-3-了解编译系统如何工作的益处"><a href="#1-3-了解编译系统如何工作的益处" class="headerlink" title="1.3 了解编译系统如何工作的益处"></a>1.3 了解编译系统如何工作的益处</h2></li>
<li>优化程序性能</li>
<li>理解链接时出现的错误</li>
<li>避免安全漏洞<h2 id="1-4-处理器读并解释存储在内存中的指令"><a href="#1-4-处理器读并解释存储在内存中的指令" class="headerlink" title="1.4 处理器读并解释存储在内存中的指令"></a>1.4 处理器读并解释存储在内存中的指令</h2><h3 id="1-4-1系统的硬件组成"><a href="#1-4-1系统的硬件组成" class="headerlink" title="1.4.1系统的硬件组成"></a>1.4.1系统的硬件组成</h3></li>
</ul>
<ol>
<li><p>总线</p>
<ol>
<li>贯穿系统的一组电子管道；</li>
<li>传送定长的字节块，也就是字（word);</li>
<li>字中的字节数（字长）是系统的基本参数，大多为4个字节（32位），或者8个字节（64位）；</li>
</ol>
</li>
<li><p>I/O设备</p>
<ol>
<li>I/O（输入/输出）设备;</li>
<li>每个I/O设备都通过一个控制器或适配器与I/O总线相连;</li>
<li>控制器和适配器的功能 是在I/O总线和I/O设备直接按传递信息；它们之间的区别在于 封装方式。控制器是I/O设备本身或者系统的主印制电路板（主板）上的芯片组；适配器则是一块插在主板插槽上的卡;</li>
</ol>
</li>
<li><p>主存</p>
<ol>
<li>主存是一个临时存储设备，在处理器执行程序时，用来存放程序和程序处理的数据;</li>
<li>物理上来说，主存由一组<strong>动态随机存取存储器</strong>（DRAM）芯片组成；</li>
<li>逻辑上来说，存储器是一个线性的字节数组，每个字节都有其唯一的地址（数组索引）[从零开始的地址]</li>
<li>一般来说，组成程序的每条机器指令都由不同数量的字节构成。</li>
</ol>
</li>
<li><p>处理器</p>
<ol>
<li>中央处理单元（CPU),简称处理器，解释（或执行)存储在主存中指令的引擎；</li>
<li>核心是一个的大小位一个字的存储设备（或寄存器），即程序计数器（PC）；</li>
<li>PC指向贮存中的某条机器语言指令(即含有该条指令的地址）；</li>
<li>寄存器文件（register file) 是一个小的存储设备，由一些单个字长的寄存器组成，每个寄存器都有唯一的名字。</li>
<li><strong>算术/逻辑单元</strong>（ALU) 计算新的数据和地址。</li>
</ol>
</li>
</ol>
<h3 id="1-4-2-运行hello程序"><a href="#1-4-2-运行hello程序" class="headerlink" title="1.4.2 运行hello程序"></a>1.4.2 运行hello程序</h3><ul>
<li>shell程序将键盘输入的“./hello”逐一读入寄存器，再把它存放到内存中；/或者利用直接存储器存取（DMA）技术，数据可以不通过处理器而直接从磁盘到达主存；</li>
<li>目标文件hello中的代码和数据被加载到主存，处理器开始执行hello程序的main程序中的机器语言指令，即将“hello, world\n”字符串中的字节从主存复制到寄存器文件，再从寄存器文件复制到显示设备，最终显示再屏幕上。</li>
</ul>
<h2 id="1-5-高速缓存至关重要"><a href="#1-5-高速缓存至关重要" class="headerlink" title="1.5 高速缓存至关重要"></a>1.5 高速缓存至关重要</h2><ul>
<li>机械原理：加大存储设备要比较小的存储设备运行的慢，而快速设备的造价远高于同类的低速设备；</li>
<li>处理器从寄存器文件中读取数据比从贮存中读取快，随着半导体技术的进步，这种处理器与主存之间的差距还在增大，加快处理的运行速度要比加快竹村的运行速度要容易和便宜得多。</li>
<li>高速缓存存储器（cache memory,简称 cache 或高速缓存），位于处理器芯片上的L1(容量可以达到数万字节），访问速度近似于访问存储器文件；L2高速缓存（数十万到数百万字节）通过一条特殊的总线连接到处理器，访问L2的时间比访问L1的时间长5倍，但仍比访问主存速度快5-10倍。</li>
<li>L1、L2采用<strong>静态随机访问存储器</strong>的硬件技术实现的， 比较新、 处理能力更强大的系统有三级高速缓存：L1、L2和L3；</li>
<li>系统可以获得一个很大的存储起，同时访问速度也很快，原因是利用了告诉缓存的局部性原理，即程序具有访问局部区域里数据和代码的趋势。通过让告诉缓存里存放可能经常访问的数据，大部分的内存操作都能再快速的告诉缓存中完成。</li>
<li>意识到高速存储器存在的应用程序员能够利用高速缓存将程序的性能提高一个数量级。</li>
</ul>
<h2 id="1-6-存储设备形成层次结构"><a href="#1-6-存储设备形成层次结构" class="headerlink" title="1.6 存储设备形成层次结构"></a>1.6 存储设备形成层次结构</h2><p>存储器层次:</p>
<ul>
<li>L0: 寄存器</li>
<li>L1: L1高速缓存（SRAM)</li>
<li>L2: L2高速缓存（SRAM)</li>
<li>L3: L3高速缓存（SRAM)</li>
<li>L4: 主存（DRAM)</li>
<li>L5: 本地二级存储(本地磁盘）</li>
<li><p>L6: 远地二级存储（分布式文件系统，Web服务器）</p>
</li>
<li><p>这个层次中 从上至下，设备的访问速度越来越慢、容量越来越大、并且每字节的造价越来越便宜；</p>
</li>
<li>存储器层次结构的主要思想是上一层的存储器作为第一层存储器的高速缓存；</li>
</ul>
<h2 id="1-7操作系统管理硬件"><a href="#1-7操作系统管理硬件" class="headerlink" title="1.7操作系统管理硬件"></a>1.7操作系统管理硬件</h2><ul>
<li><p>操作系统的两个基本功能：</p>
<ol>
<li>防止硬件被失控的应用程序滥用；</li>
<li>向应用程序提供简单一直的机制来控制复杂而又通常不大相同的低级硬件设备；</li>
</ol>
</li>
<li><p>操作系统通过几个基本的抽象概念（进程、虚拟内存和文件）来实现这两个功能。</p>
</li>
<li>文件时对I/O设备的抽象表示，虚拟内存时对主存和磁盘I/O设备的表示，进程则是对处理器、主存和I/O设备的抽象表示。</li>
</ul>
<h3 id="1-7-1-进程"><a href="#1-7-1-进程" class="headerlink" title="1.7.1 进程"></a>1.7.1 进程</h3><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p> 处理器看上去像在不间断地一条接一条地执行程序中地指令，即该程序的代码和数据是内存中唯一的对象。这些假象是通过对进程的概念来实现的。</p>
<ul>
<li><strong>进程</strong>概念：是操作系统对一个正在进行的程序的一种抽象。在一个系统上可以同时运行多个进程，而每个进程都好像在独占地使用硬件。</li>
<li><strong>并发运行</strong>概念：则是说一个进程地指令和另一个进程地指令是交错执行的。<ul>
<li>在大多数系统中，需要运行地进程数多于可以运行它们地CPU个数的。传统系统在一个时刻只能执行一个程序，而先进的多核处理器能偶同时执行多个程序。</li>
<li>无论是单核还是多核处理器，一个CPU看上去都像是在并发地执行多个进程，这是通过处理器在进程间地切换来实现的。<br><strong>上下文切换</strong>概念：操作系统实现这种交错执行的机制。</li>
</ul>
</li>
<li><strong>上下文</strong>概念：操作系统保持跟踪进程运行所需地所有状态信息的状态。包括：PC和寄存器文件的当前值，以及主存的内容。</li>
<li>单处理器系统，在任何一个时刻都只能执行一个进程的代码。当操作系统决定要把控制权从当前进程转移到某个新进程时，就会进程<em>上下文切换</em>，即<em>保存当前进程的上下文、恢复新进程的上下文，然后将控制器传递到新进程，新进程将会会从它上次保存的地方开始</em>。<h4 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h4></li>
<li>内核是系统管理全部进程所用代码和数据结构的集合。内核不是一个独立的进程。</li>
<li>从一个进程到另一个进程的转换是由操作系统的内核（kernel)管理的.内核时操作系统代码常驻主存的部分。</li>
<li>当应用程序需要操作系统的某些操作时，比如读写文件，它（应用程序）就执行一条特殊的系统调用（system call）指令，将控制权传递给内核。然后内核执行被请求的操作并返回应用程序。</li>
</ul>
<h3 id="1-7-2-线程"><a href="#1-7-2-线程" class="headerlink" title="1.7.2 线程"></a>1.7.2 线程</h3><ul>
<li>现代系统中，一个进程实际上由多个称为<em>线程</em>的执行单元组成，每个线程都是运行在进程的上下文中，并共享同样的代码和全局数据。</li>
<li>由于网络服务器中对并行处理的需求，且多线程之间比多进程之间更容易共享数据，以及线程一般来说都比进程更高效，所以线程成为越来越重要的编程模型。</li>
<li>当有多处理器可用的时候，多线程也是一种使得程序可以运行得更快的方法。</li>
</ul>
<h3 id="1-7-3-虚拟内存"><a href="#1-7-3-虚拟内存" class="headerlink" title="1.7.3 虚拟内存"></a>1.7.3 虚拟内存</h3><ul>
<li>虚拟内存是一个抽象概念，它为每一个进程提供里一个假象，即每个进程都在独占地使用主存。每个进程看到的内存都是一致地，称为<em>虚拟地址空间</em>。</li>
<li>在 Linux 中， 地址空间最上面的区域是保留给操作系统中的代码和数据的，这对所有进程来说都是一样。</li>
<li>地址空间的底部区域存放用户进程定义的代码和数据。 </li>
</ul>
<h4 id="虚拟地址空间中的区"><a href="#虚拟地址空间中的区" class="headerlink" title="虚拟地址空间中的区"></a>虚拟地址空间中的区</h4><p>每个进程看到的虚拟地址空间由大量准确定义的区构成，每个区都有专门的功能。</p>
<ul>
<li><strong>程序代码和数据</strong>。 对所有的进程来说，代码是从同一固定地址开始，紧接着的是和C全局变量相对应的数据位置。代码和数据区是直接按照可执行目标文件的内容初始化的,</li>
<li><strong>堆</strong>。代码和数据区后面紧随的是运行时堆。代码和数据区在进程一开始运行就被指定了大小，与此不同，当调用像malloc和free这样的C标准库函数时， 堆可以在运行时动态地扩展和收缩。 </li>
<li><strong>共享库</strong>。 大约在地址空间的中间部分是一块用来存放像C标准库和数学库这样的共享库的代码和数据的区域。 </li>
<li><strong>栈</strong>。 位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数的调用。和堆一样，用户栈在程序执行期间可以动态地扩展和收缩。特别地，每次我们调用一个函数时，栈就会增长；从一个函数返回时，栈就会收缩。</li>
<li><strong>内核虚拟内存</strong>。地址空间顶部的区域是为内核保留的。 不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。 相反， 它们必须调用内核来执行这些操作。</li>
</ul>
<p>虚拟内存的运作需要硬件和操作系统软件之间精密复杂的交互， 包括对处理器生成的每个地址的硬件翻译。基本思想是把一个进程虚拟内存的内容存储在磁盘上，然后用主存作为磁盘的高速缓存。</p>
<h3 id="1-7-4-文件"><a href="#1-7-4-文件" class="headerlink" title="1.7.4 文件"></a>1.7.4 文件</h3><ul>
<li>文件就是字节序列。</li>
<li>每个 I/0 设备， 包括磁盘、 键盘、 显示器， 甚至网络，都可以看成是文件。文件向应用程序提供了一个统一的视图，来看待系统中可能含有的所有各式各样的的I/O设备。</li>
<li>系统中所有的输入输出设备都是通过使用一小组称为Unix I/O的系统函数调用读写文件来实现的。</li>
</ul>
<h2 id="1-8-系统之间利用网络通信"><a href="#1-8-系统之间利用网络通信" class="headerlink" title="1.8 系统之间利用网络通信"></a>1.8 系统之间利用网络通信</h2><ul>
<li>从 个单独的系统来看， 网络可视为一个 I/O设备。</li>
<li>当系统从主存复制一串字节到网络适配器时， 数据流经过网络到达另一台机器，而不是比如说到达本地磁盘驱动器。相似地，系统可以读取其他机器发送来的数据，并把数据复制到自己的主存。</li>
</ul>
<h2 id="1-9重要主题"><a href="#1-9重要主题" class="headerlink" title="1.9重要主题"></a>1.9重要主题</h2><ul>
<li>重要的观点：系统不只是硬件。系统是硬件和系统软件互相交织的集合体，它们必须共同协作以达到运行应用程序的目的。</li>
</ul>
<h3 id="1-9-1-Amdahl定理"><a href="#1-9-1-Amdahl定理" class="headerlink" title="1.9.1 Amdahl定理"></a>1.9.1 Amdahl定理</h3><ul>
<li>该定律的主要思想是：当我们对系统的某个部分加速时，其对系统整体性能的影响取决于该部分的重要性和加速程度。</li>
<li>若系统执行某应用程序需要时间为T，假设系统某部分所需执行时间与该时间的比例为 a, 而该部分性能提升比例为k。即该部分初始所需时间为 aT，现在所需时间为（aT)/k。因此，总的执行时间应为</li>
<li>T=（1-a)T+（aT）/k = T[（1-a) +a/k]</li>
<li>Amdahl 定律的主要观点——想显著加速整个系统，必须提升全系统中相当大的部分的速度。</li>
<li>另： S=1/(1-a+a/n)<br>其中，a为并行计算部分所占比例，n为并行处理结点个数。这样，当1-a=0时，(即没有串行，只有并行)最大加速比s=n；当a=0时（即只有串行，没有并行），最小加速比s=1；当n→∞时，极限加速比s→ 1/（1-a），这也就是加速比的上限。例如，若串行代码占整个代码的25%，则并行处理的总体性能不可能超过4。这一公式已被学术界所接受，并被称做“阿姆达尔定律”，也称为“安达尔定理”(Amdahl law)。<h3 id="1-9-2并发和并行"><a href="#1-9-2并发和并行" class="headerlink" title="1.9.2并发和并行"></a>1.9.2并发和并行</h3></li>
<li>两个需求是驱动进步的持续动力：想要计算机做的更多；想要计算机运行得更快。 当处理器能够同时做更多的事情时，这两个因素都会改进。</li>
<li>术语<strong>并发</strong>(concurrency)是一个通用的概念， 指一个同时具 有多个活动的系统；而术语<strong>并行</strong>(parallelism) 指的是用并发来使一个系统运行得更快，并行可以在计算机系统的多个抽象层次上运用。 <h4 id="1-线程级并发"><a href="#1-线程级并发" class="headerlink" title="1.线程级并发"></a>1.线程级并发</h4></li>
<li>构建在进程这个抽象之上，我们能够设计出同时有多个程序执行的系统，这就导致了并发。 使用线程，我们甚至能够在一个进程中执行多个<strong>控制流</strong>。（控制流是指<em>按一定的顺序排列程序元素来决定程序执行的顺序，语句按照出现在程序中的顺序执行</em>。）<br>自 20 世纪 60 年代初期出现时间共享以来， 计算机系统中就开始有了对并发执行的支持。 </li>
<li>传统意义上， 这种并发执行只是模拟出来的， 是通过使一台计算机在它正在执行的进程间快速切换来实现的， 就好像一个杂耍艺人保持多个球在空中飞舞一样。 </li>
<li>这种并发形式允许多个用户同时与系统交互，在以前， 即使处理器必须在多个任务间切换， 大多数实际的计算也都是由一个处理器来完成的。 这种配置称为单处理器系统。</li>
</ul>
<p>当构建一个由单操作系统内核控制的多处理器组成的系统时， 我们就得到了一个多处理器系统。 其实从 20 世纪 80 年代开始， 在大规模的计算中就有了这种系统，但是直到最近，随着多核处理器和超线程 (hyperthreading) 的出现，这种系统才变得常见。</p>
<ul>
<li><strong>多核处理器</strong>是将多个 CPU（简称”核“)集成到一个集成电路芯片上。</li>
<li><strong>超线程</strong>，有时称为同时多线程 (simultaneous multi-threading), 是一项允许一个CPU执行多个控制流的技术。</li>
</ul>
<p>它涉及 CPU 某些硬件有多个备份， 比如程序计数器和寄存器文件， 而其他的硬件部分只有一份， 比如执行浮点算术运算的单元。</p>
<ul>
<li>超线程的处理器可以在单个周期的基础上决定要执行哪一个线程。 这使得 CPU 能够更好地利用它的处理资源。</li>
<li>多线程的使用对系统性能的提高：首先， 它减少了在执行多个任务时模拟 并发的需要。  其次， 它可以使应用程序运行得更快， 当然， 这必须要求程序是以多线程方式来书写的， 这些线程可以并行地高效执行。<h4 id="2-指令级并行"><a href="#2-指令级并行" class="headerlink" title="2.指令级并行"></a>2.指令级并行</h4></li>
<li>在较低的抽象层次上， 现代处理器可以同时执行多条指令的属性称为<strong>指令级并行</strong>。 </li>
<li>在<strong>流水线</strong>中， 将执行一条指令所需要的活动划分成不同的步骤，将处理器的硬件组织成一系列的阶段，每个阶段执行一个步骤。这些阶段可以并行地操作，用来处理不同指令地不同部分。</li>
<li>如果处理器可以达到比一个周期一条指令更快的执行速率， 就称之为超标量(superscalar)处理器。大多数现代处理器都支持超标量操作。</li>
</ul>
<h4 id="3-单指令、多数据并行"><a href="#3-单指令、多数据并行" class="headerlink" title="3.单指令、多数据并行"></a>3.单指令、多数据并行</h4><ul>
<li>在最低层次上， 许多现代处理器拥有特殊的硬件， 允许一条指令产生多个可以并行执行地操作，这种方式称为<strong>单指令、多数据</strong>，即 SIMD 并行。 </li>
</ul>
<p>例如， 较新几代的Intel和AMD处理器都具有并行地对8对单精度浮点数CC数据类型float)做加法的指令。<br>提供这些SIMD指令多是为了提高处理影像、 声音和视频数据应用的执行速度。 虽然 有些编译器会试图从C程序中自动抽取SIMD并行性， 但是<em>更可靠的方法</em>是用编译器支持的特殊的向量数据类型来写程序，</p>
<h3 id="1-9-3-计算机系统中抽象地重要性"><a href="#1-9-3-计算机系统中抽象地重要性" class="headerlink" title="1.9.3 计算机系统中抽象地重要性"></a>1.9.3 计算机系统中抽象地重要性</h3><p>在处理器里， 指令集架构提供了对实际处理器硬件的抽象。 使用这个抽象， 机器代码程序表现得就好像运行在一个一次只执行一条指令的处理器上。 底层的硬件远比抽象描述的要复杂精细， 它并行地执行多条指令， 但又总是与那个简单有序的模型保持一致。 只要执行模型一样， 不同的处理器实现也能执行同样的机器代码， 而又提供不同的开销和性能。<br>四个抽象：<strong>文件</strong>是对I/0设备的抽象， <strong>虚拟内存</strong>是对程序存储器的抽象， <strong>进程</strong>是对一个正在运行的程序的抽象。而<strong>虚拟机</strong>，它提供对整个计算机的抽象， 包括操作系统、 处理器和程序。</p>
<h3 id="1-10-小结"><a href="#1-10-小结" class="headerlink" title="1.10 小结"></a>1.10 小结</h3><ul>
<li>计算机系统是由硬件和系统软件组成的， 它们共同协作以运行应用程序。计算机内部的信息被表示为一组组的位， 它们依据上下文有不同的解释方式。程序被其他程序翻译成不同的形式， 开始时是 ASCII文本， 然后被编译器和链接器翻译成二进制可执行文件。</li>
<li>处理器读取并解释存放在主存里的二进制指令。因为计算机花费了大量的时间在内存、I/0 设备和 CPU寄存器之间复制数据 ， 所以将系统中的存储设备划分成层次结构 CPU寄存器在顶部， 接着是多层的硬件高速缓存存储器、DRAM主存和磁盘存储器。</li>
<li>在层次模型中， 位于更高层的存储设备比低层的存储设备要更快， 单位比特造价也更高。层次结构中较高层次的存储设备可以作为较低层次设备的高速缓存。通过理解和运用这 种存储层次结构的知识， 程序员可以优化C程序的性能。</li>
<li>操作系统内核是应用程序和硬件之间的媒介。<br>它提供了三个基本的抽象：1）文件是对I/O设备的抽象；2）虚拟内存是对主存和磁盘的抽象；3）进程是处理器、主存和I/O设备的抽象。</li>
<li>最后， 网络提供了计算机系统之间通信的手段。从特殊系统的角度来看 ， 网络就是一种 I/0 设备。</li>
</ul>

  </section>

  <section class="post-comments">

    <!-- 将评论系统（例如Disqus、多说、友言、畅言等）提供的代码片段粘贴在这里 -->
    
</section>


</article>


            <footer class="footer">

    <span class="footer__copyright">&copy; 2014-2015. | 由<a href="https://hexo.io/">Hexo</a>强力驱动 | 主题<a href="https://github.com/someus/huno">Huno</a></span>
    
</footer>
        </div>
    </div>

    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>
    

    

    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript"> 
        $(document).ready(function(){
            MathJax.Hub.Config({ 
                tex2jax: {inlineMath: [['[latex]','[/latex]'], ['\\(','\\)']]} 
            });
        });
    </script>


    

    <script src="/js/jquery.min.js"></script>
    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    
    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

</body>
</html>
