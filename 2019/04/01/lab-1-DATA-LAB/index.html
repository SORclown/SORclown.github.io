<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      lab 1 DATA LAB | Hexo 
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
      <meta name="author" content="John Doe">
    
    

    <meta name="description" content="Data lab假设你的机器：1.使用补码，32位整数表示。 2.算术上进行右移。 3.当移动整数超过字大小时，具有不可预测的行为。 一.位操作禁止：  1.使用任何控制结构，如if，do，while，for，switch等。  2.定义或使用任何宏。  3.在此文件中定义任何其他功能。  4.调用任何功能。  5.使用任何其他操作，例如&amp;amp;&amp;amp;，||， - 或？：  6.使用任何形式">
<meta property="og:type" content="article">
<meta property="og:title" content="lab 1 DATA LAB | Hexo">
<meta property="og:url" content="http://yoursite.com/2019/04/01/lab-1-DATA-LAB/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Data lab假设你的机器：1.使用补码，32位整数表示。 2.算术上进行右移。 3.当移动整数超过字大小时，具有不可预测的行为。 一.位操作禁止：  1.使用任何控制结构，如if，do，while，for，switch等。  2.定义或使用任何宏。  3.在此文件中定义任何其他功能。  4.调用任何功能。  5.使用任何其他操作，例如&amp;amp;&amp;amp;，||， - 或？：  6.使用任何形式">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-04-01T14:01:04.975Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lab 1 DATA LAB | Hexo">
<meta name="twitter:description" content="Data lab假设你的机器：1.使用补码，32位整数表示。 2.算术上进行右移。 3.当移动整数超过字大小时，具有不可预测的行为。 一.位操作禁止：  1.使用任何控制结构，如if，do，while，for，switch等。  2.定义或使用任何宏。  3.在此文件中定义任何其他功能。  4.调用任何功能。  5.使用任何其他操作，例如&amp;amp;&amp;amp;，||， - 或？：  6.使用任何形式">
    
    
    
      <link rel="icon" type="image/x-icon" href="/favicon.png">
    
    <link rel="stylesheet" href="/css/uno.css">
    <link rel="stylesheet" href="/css/highlight.css">
    <link rel="stylesheet" href="/css/archive.css">
    <link rel="stylesheet" href="/css/china-social-icon.css">

</head>
<body>

    <span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

    

<header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">

  
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">Hexo</a></h1>
        <hr class="panel-cover__divider">

        

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">首页</a></li>
              
                
                <li class="navigation__item"><a href="/about" title="" class="">关于</a></li>
              
                
                <li class="navigation__item"><a href="/archive" title="" class="">归档</a></li>
              

            </ul>
          </nav>

          <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->



        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            

<article class="post-container post-container--single">

  <header class="post-header">
    
    <h1 class="post-title">lab 1 DATA LAB</h1>

    

    <div class="post-meta">
      <time datetime="2019-04-01" class="post-meta__date date">2019-04-01</time> 

      <span class="post-meta__tags tags">

          

          

      </span>
    </div>
    
    

  </header>

  <section id="post-content" class="article-content post">
    <h1 id="Data-lab"><a href="#Data-lab" class="headerlink" title="Data lab"></a>Data lab</h1><p>假设你的机器：<br>1.使用补码，32位整数表示。<br> 2.算术上进行右移。<br> 3.当移动整数超过字大小时，具有不可预测的行为。</p>
<h2 id="一-位操作"><a href="#一-位操作" class="headerlink" title="一.位操作"></a>一.位操作</h2><p>禁止：<br>  1.使用任何控制结构，如if，do，while，for，switch等。<br>  2.定义或使用任何宏。<br>  3.在此文件中定义任何其他功能。<br>  4.调用任何功能。<br>  5.使用任何其他操作，例如&amp;&amp;，||， - 或？：<br>  6.使用任何形式的强制转换。<br>  7.使用除int之外的任何数据类型。这意味着你不能使用数组，结构或联合。</p>
<h3 id="1-bitAnd-x-amp-y"><a href="#1-bitAnd-x-amp-y" class="headerlink" title="1.bitAnd x&amp;y"></a>1.bitAnd x&amp;y</h3><p>实现：NOT (A AND B)=(NOT A) OR (NOT B)<br>A&amp;B=~(~A)|(~B)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">`/* 1 </span><br><span class="line">* bitAnd - x&amp;y using only ~ and |</span><br><span class="line">*   Example: bitAnd(6, 5) = 4</span><br><span class="line">*   Legal ops: ~ |</span><br><span class="line">*   Max ops: 8</span><br><span class="line">*   Rating: 1</span><br><span class="line">*/`</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int bitAnd(int x, int y)</span><br><span class="line">&#123;</span><br><span class="line">    return ~((~x)|(~y));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int bitAnd( int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    int result;</span><br><span class="line">    int x1=~x,y1=~y; //x1 1001; y1 1010</span><br><span class="line">    </span><br><span class="line">    result=(~x)|(~y); //result 1011 =-5</span><br><span class="line">    result=~result; // result 0100 =4</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>德摩根定律<br>代码：</p>
<ol>
<li>先对二进制x和y分别取反</li>
<li>再对取反后得到的二进制求或</li>
<li>对求或 得到的二进制求反<br>6   0110<br>5   0101<br>5&amp;6 0100 =4</li>
</ol>
<h3 id="2-getByte-int-x-int-n"><a href="#2-getByte-int-x-int-n" class="headerlink" title="2.getByte(int x, int n)"></a>2.getByte(int x, int n)</h3><p>/*   </p>
<ul>
<li>getByte - Extract byte n from word x </li>
<li>Bytes numbered from 0 (LSB) to 3 (MSB) </li>
<li>Examples: getByte(0x12345678,1) = 0x56 </li>
<li>Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; </li>
<li>Max ops: 6 </li>
<li>Rating: 2<br>*/</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int getByte(int x, int n) </span><br><span class="line">&#123;</span><br><span class="line">    int tmp = x &gt;&gt; ( (n) &lt;&lt; 3 );//一个字节里有八个bits,对 n&lt;&lt;3 即 n*=8, x&gt;&gt; 8*n位，位移后的最低字节即为想要的字节</span><br><span class="line">    tmp =tmp &amp; 0xFF; //0xff 二进制 1111 1111 ; 与运算 有效位高位被省去。</span><br><span class="line">    return tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提取出从右往左数第n个字节<br>取出第i字节（i=0,1,2,3），一个Byte是两个16进制数，也就是8bits，所以可以直接右移8×n位，然后取最后八位，就是&amp;0xff（255，没超规定范围常数）</p>
<h3 id="3-logicalShift-int-x-int-n"><a href="#3-logicalShift-int-x-int-n" class="headerlink" title="3.logicalShift( int x ,int n)"></a>3.logicalShift( int x ,int n)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* 3 </span><br><span class="line">* logicalShift - shift x to the right by n, using a logical shift </span><br><span class="line">* Can assume that 0 &lt;= n &lt;= 31 </span><br><span class="line">* Examples: logicalShift(0x87654321,4) = 0x08765432 </span><br><span class="line">* Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line">* Max ops: 20 </span><br><span class="line">* Rating: 3 </span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>1001 0011 &gt;&gt; 3<br>000 10010 逻辑右移<br>111 10010 算术右移</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int logicalShift(int x, int n)</span><br><span class="line">&#123;</span><br><span class="line">    int tmpn = 32 +( (~n) +1 );//n&gt;0 (~n)+1=-n; 32+( (~n) +1 )=32-n  用tmpn记录右移长度</span><br><span class="line">    int tmp = (1&lt;&lt; tmpn)+(~0) + ( (~(!n))+1);//制作一个tmp 让 tmp 的前n位空出来，即0x00..fff=000..111</span><br><span class="line">    int ans = (x &gt;&gt; n) &amp; tmp;//对 x 默认进行算术位移     </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return ans ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.bitCount<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* 4</span><br><span class="line">* bitCount - returns count of number of 1&apos;s in word</span><br><span class="line">*   Examples: bitCount(5) = 2, bitCount(7) = 3</span><br><span class="line">*   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line">*   Max ops: 40</span><br><span class="line">*   Rating: 4</span><br><span class="line">*/</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">int bitCount(int x) &#123;</span><br><span class="line">  int _mask1 = (0x55)|(0x55&lt;&lt;8);</span><br><span class="line">  int _mask2 = (0x33)|(0x33&lt;&lt;8);</span><br><span class="line">  int _mask3 = (0x0f)|(0x0f&lt;&lt;8);</span><br><span class="line">  int mask1 = _mask1|(_mask1&lt;&lt;16);</span><br><span class="line">  int mask2 = _mask2|(_mask2&lt;&lt;16);</span><br><span class="line">  int mask3 = _mask3|(_mask3&lt;&lt;16);</span><br><span class="line">  int mask4 = (0xff)|(0xff&lt;&lt;8);</span><br><span class="line">  int mask5 = (0xff)|(0xff&lt;&lt;16);</span><br><span class="line">//mask1=0x55555555;01010101 间隔1个零</span><br><span class="line">//mask2=0x33333333;00110011 间隔2个零</span><br><span class="line">//mask3=0x0f0f0f0f;00001111 间隔4个零</span><br><span class="line">//mask4=0x00ff00ff;0000 0000 1111 1111 间隔8个零</span><br><span class="line">//mask5=0x0000ffff;0000 0000 0000 0000 1111 1111 1111 1111 间隔16个零</span><br><span class="line"></span><br><span class="line">  int ans = (x &amp; mask1) + ((x&gt;&gt;1) &amp; mask1);//5+0=5 0101；  </span><br><span class="line">//b0*2^0+b1*2^1+b2*2^2+...+b30*2^30+b31*2^31</span><br><span class="line">//(b0+b1)*2^0+(b2+b3)*2^2+...+(b30+b31)*2^30</span><br><span class="line">  ans = (ans &amp; mask2) + ((ans&gt;&gt;2) &amp; mask2);//1+1=2 0010；</span><br><span class="line">  ans = (ans &amp; mask3) + ((ans&gt;&gt;4) &amp; mask3);//2+0=2 0010；</span><br><span class="line">  ans = (ans &amp; mask4) + ((ans&gt;&gt;8) &amp; mask4);//2+0=2 0010；</span><br><span class="line">  ans = (ans &amp; mask5) + ((ans&gt;&gt;16) &amp; mask5);//2+0=2 0010；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://i.loli.net/2019/04/01/5ca218271108a.png" target="_blank" rel="noopener">image</a></p>
<p>为什么这么设计呢，可以把5个数字的二进制写出来，分别是间隔1个0,2个0,4个0,8个0,16个0<br>然后下面的计算方法，和间隔对应，分别右移1,2,4,8,16次。<br>如何理解呢，如果只给你一个只有2位的二进制数x，以及01，怎么计算里面1的个数呢，是不是做(x&amp;1)+((x&gt;&gt;1)&amp;1)呢？通过移位，把高位的1，移到低位求和。<br>32位的数字就可以看成是16个2位的，之后就可以等价看作，一个16位的数字，分成8段，做上面第二个计算操作。</p>
<h3 id="5-bang"><a href="#5-bang" class="headerlink" title="5.bang"></a>5.bang</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">*   bang - Compute !x without using !</span><br><span class="line">*   Examples: bang(3) = 0, bang(0) = 1</span><br><span class="line">*   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line">*   Max ops: 12</span><br><span class="line">*   Rating: 4</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int bang(int x) &#123;</span><br><span class="line">  return ((~(x|(~x+1)))&gt;&gt;31)&amp;1;&#125;</span><br></pre></td></tr></table></figure>
<p>我们得知道一个特性就是0x0…000 | ((~0x0…000)+1)还是等于0x0…000，但是其他任何数自己|上自己的相反数最高位一定是1，这就是关键点了。然后把最高位右移31位来判断是否为0即可。</p>
<h2 id="二-补码"><a href="#二-补码" class="headerlink" title="二.补码"></a>二.补码</h2><p>计算机中用补码表示有符号数，最高位是符号位，并且范围有所不同，特别需要注意TMin。</p>
<h3 id="6-tmin"><a href="#6-tmin" class="headerlink" title="6.tmin"></a>6.tmin</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* 6</span><br><span class="line">* tmin - return minimum two&apos;s complement integer</span><br><span class="line">*   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line">*   Max ops: 4</span><br><span class="line">*   Rating: 1</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>int tmin(void)<br>{<br>  return 1&lt;&lt;31;<br>}</p>
<p>题目：返回补码整数的最小整数数值。<br>0x80000000就是补码整数的最小值。</p>
<h3 id="7-fitsBits"><a href="#7-fitsBits" class="headerlink" title="7. fitsBits"></a>7. fitsBits</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* 7 </span><br><span class="line">* fitsBits - return 1 if x can be represented as an</span><br><span class="line">*  n-bit, two&apos;s complement integer.</span><br><span class="line">*   1 &lt;= n &lt;= 32</span><br><span class="line">*   Examples: fitsBits(5,3) = 0, fitsBits(-4,3) = 1</span><br><span class="line">*   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line">*   Max ops: 15</span><br><span class="line">*   Rating: 2</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int fitsBits(int x, int n)</span><br><span class="line">&#123;</span><br><span class="line">  return !(((x&gt;&gt;(n+(~0)))+1)&gt;&gt;1);// 1. 5 0101&gt;&gt;2=0001 2. 0001+ 1 =0010; 3.!（(0010)&gt;&gt;1）=!（0001）=0；</span><br><span class="line">                                 // 1.-4 100&gt;&gt;2=1111  2. 1111+ 1 =0000; 3.!(0000&gt;1)=1;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题目：只给出n个二进制位，能否表示x。<br>如果是非负数，在n位范围内，应该只有最低n-1位里有1,<br>如果是负数，应该是只有最低n-1位里有0。<br>所以对范围内的数字右移n-1位之后，应该要么是全1，要么是全0，然后这会对它+1，再右移一位，就会变成全0了。</p>
<h3 id="8-divpwr2"><a href="#8-divpwr2" class="headerlink" title="8. divpwr2"></a>8. divpwr2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/* 8 </span><br><span class="line">* divpwr2 - Compute x/(2^n), for 0 &lt;= n &lt;= 30</span><br><span class="line">*  Round toward zero</span><br><span class="line">*   Examples: divpwr2(15,1) = 7, divpwr2(-33,4) = -2</span><br><span class="line">*   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line">*   Max ops: 15</span><br><span class="line">*   Rating: 2</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int divpwr2(int x, int n)&#123;</span><br><span class="line">    int tmp = (~( (x &gt;&gt; 31) &amp; 0x1) )+1 ;//判断是不是负数tmp=(~( (x &gt;&gt; 31) &amp; 0x1) )+1，是负数构造出 tmp=0xF...FFF出来</span><br><span class="line">    int q= ~((~0)&lt;&lt;n);//q=2^n-1 -&gt; 0xff..ff -&gt; 0xff..00 -&gt;  0x11..11..00.00 -&gt; 0x00..0011...11</span><br><span class="line">    int ans = (x + (tmp &amp; q) ) &gt;&gt; n ;</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题目：给出整数x，整数n，求[x/(2^n)]，答案要接近趋向0方向。</p>
<h3 id="9-negate"><a href="#9-negate" class="headerlink" title="9. negate"></a>9. negate</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* 9 </span><br><span class="line">* negate - return -x</span><br><span class="line">*   Example: negate(1) = -1.</span><br><span class="line">*   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line">*   Max ops: 5</span><br><span class="line">*   Rating: 2</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int negate(int x) </span><br><span class="line">&#123;</span><br><span class="line">  return ~x+1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题目：给定x求-x<br>想法：定理x的相反数是(~x)+1</p>
<h3 id="10-isPositive"><a href="#10-isPositive" class="headerlink" title="10. isPositive"></a>10. isPositive</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* 10 </span><br><span class="line">* isPositive - return 1 if x &gt; 0, return 0 otherwise</span><br><span class="line">*   Example: isPositive(-1) = 0.</span><br><span class="line">*   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line">*   Max ops: 8</span><br><span class="line">*   Rating: 3</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return !((x&gt;&gt;31)|(!x));</span><br></pre></td></tr></table></figure>
<p>题目：判断x是不是正数<br>想法：先判断是不是负数，或者说是0，如果是其中一种情况就不是大于0的数，瞬间解决。</p>
<h3 id="11-isLessOrEqual"><a href="#11-isLessOrEqual" class="headerlink" title="11. isLessOrEqual"></a>11. isLessOrEqual</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* 11 </span><br><span class="line">* isLessOrEqual - if x &lt;= y  then return 1, else return 0</span><br><span class="line">*   Example: isLessOrEqual(4,5) = 1.</span><br><span class="line">*   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line">*   Max ops: 24</span><br><span class="line">*   Rating: 3</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int isLessOrEqual(int x, int y) </span><br><span class="line">&#123;</span><br><span class="line">    int a = y + ~x + 1;</span><br><span class="line">    return (!!a &amp; !((a &gt;&gt; 31) &amp; 1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题目：用位运算判定x&lt;=y，如果是就返回1，如果不是就返回0。<br>思路：x的相反数等于 （~x+1), a=y-x,判断a</p>
<h3 id="12-ilog2"><a href="#12-ilog2" class="headerlink" title="12. ilog2"></a>12. ilog2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/* 12 √</span><br><span class="line">* ilog2 - return floor(log base 2 of x), where x &gt; 0</span><br><span class="line">*   Example: ilog2(16) = 4</span><br><span class="line">*   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="line">*   Max ops: 90</span><br><span class="line">*   Rating: 4</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int ilog2(int x) </span><br><span class="line">&#123;</span><br><span class="line">  int ans = 0;</span><br><span class="line">  ans =  ((!!(x&gt;&gt;(16)))&lt;&lt;4);//16 000..010000</span><br><span class="line">  ans = ans + ((!!(x&gt;&gt;(8 + ans)))&lt;&lt;3);</span><br><span class="line">  ans = ans + ((!!(x&gt;&gt;(4 + ans)))&lt;&lt;2);</span><br><span class="line">  ans = ans + ((!!(x&gt;&gt;(2 + ans)))&lt;&lt;1);</span><br><span class="line">  ans = ans + ((!!(x&gt;&gt;(1 + ans)))&lt;&lt;0);</span><br><span class="line">  </span><br><span class="line">  return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题目：求整数的log2(x)。<br>二分法的思想。<br>首先我们先将x&gt;&gt;16，判断高16位是不是还&gt;0，如果&gt;0，!(x&gt;&gt;16)就是0，我们要将他转换到a的位置就是将! !(x&gt;&gt;16)再次取非是1，然后&lt;&lt;4，到a的位置，就说明这个数大于16，1肯定在高16位处，然后在接着将高位折半到8位，就是&gt;&gt;8+16，看看高8位是不是也是&gt;0。</p>
<h2 id="三-浮点数"><a href="#三-浮点数" class="headerlink" title="三.浮点数"></a>三.浮点数</h2><p>禁止：<br>1.定义或使用任何宏。<br>2.在此文件中定义任何其他功能。<br>3.调用任何功能。<br>4.使用任何形式的强制转换。<br>5.使用除int或unsigned之外的任何数据类型。这意味着你不能使用数组，结构或联合。<br> 6.使用任何浮点数据类型，操作或常量。</p>
<p>浮点数部分可以用大部分操作，以及if和while，还有任意常数。</p>
<h3 id="13-float-neg"><a href="#13-float-neg" class="headerlink" title="13.float_neg"></a>13.float_neg</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/*  13</span><br><span class="line">*   float_neg - Return bit-level equivalent of expression -f for</span><br><span class="line">*   floating point argument f.</span><br><span class="line">*   Both the argument and result are passed as unsigned int&apos;s, but</span><br><span class="line">*   they are to be interpreted as the bit-level representations of</span><br><span class="line">*   single-precision floating point values.</span><br><span class="line">*   When argument is NaN, return argument.</span><br><span class="line">*   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span><br><span class="line">*   Max ops: 10</span><br><span class="line">*   Rating: 2</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">unsigned float_neg(unsigned uf)&#123;</span><br><span class="line">   unsigned x=0x80000000;</span><br><span class="line">   unsigned wu=0xFF000000;</span><br><span class="line">   unsigned tmp = uf&lt;&lt;1;</span><br><span class="line">   if( (wu&amp;tmp ) ==  wu)</span><br><span class="line">   &#123;</span><br><span class="line">        if(tmp != wu) return uf;</span><br><span class="line">   &#125;</span><br><span class="line">   return uf^x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题目：就是返回输入uf的负数形式-uf。如果uf是NAN形式就直接返回参数。<br>浮点数是由s(1位)E(8位)M(23位)(-1)^s <em> M </em> 2^E组成的浮点数，<br>当E是0xFF时，要么这个数是inf或NAN（整数的NaN 大多数定长的整数格式无法显式表示无效数据)，可inf也很很特殊就是M就是全0的情况所以我们捉住这个特殊点，先把uf&lt;&lt;1忽略了s，就看看0xFF000000在uf&lt;&lt;1的位置是不是也是0xFF000000，如果是再判断一下uf是不是就等于0xFF000000就代表他原先就是个inf数，如果不等于0xFF000000就代表他原先就是个NAN数。按情况加上个0x80000000即可了啊。</p>
<h3 id="14-float-i2f"><a href="#14-float-i2f" class="headerlink" title="14.float_i2f"></a>14.float_i2f</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">* float_i2f - Return bit-level equivalent of expression (float) x</span><br><span class="line">*   Result is returned as unsigned int, but</span><br><span class="line">*   it is to be interpreted as the bit-level representation of a</span><br><span class="line">*   single-precision floating point values.</span><br><span class="line">*   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span><br><span class="line">*   Max ops: 30</span><br><span class="line">*   Rating: 4</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">unsigned float_i2f(int x)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned ans;</span><br><span class="line">  int tmpx=x;</span><br><span class="line">  int f=0;</span><br><span class="line">  int delta=0;</span><br><span class="line">  int tail=0;</span><br><span class="line">  int E=0;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  if(x == 0) return x;</span><br><span class="line">  if(x == 0x80000000) return 0xcf000000;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   ans=x&amp;0x80000000;//判断x的正负  if(正) ans=0;if(负） ans=1;</span><br><span class="line">   if(ans)  tmpx = -x;//对负数的x 去相反数放到tmpx里面</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   while( (tmpx&gt;&gt;E)) E++;//确定整型 x(-x) 有几个有效位</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    E = E -1;</span><br><span class="line">    tmpx = tmpx&lt;&lt;(31-E);//向左位移并空出第一位符号位</span><br><span class="line">    tail = (tmpx &gt;&gt; 8) &amp; 0x007FFFFF;//再右移8位空出exp的8位，同时舍去长于23位的frac部分</span><br><span class="line">    f = tmpx &amp; 0xff;</span><br><span class="line">    delta =(f&gt;128) || ( (f == 128)  &amp;&amp; (tail &amp; 1) );</span><br><span class="line">    tail+=delta;//向偶数舍入</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    E=E+127;e=exp-127</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if(tail &gt;&gt; 23)</span><br><span class="line">    &#123;</span><br><span class="line">        tail = tail &amp;0x007FFFFF;</span><br><span class="line">        E+=1;</span><br><span class="line">    &#125;//防止frac部分向偶数舍入后溢出</span><br><span class="line">    ans=ans | E &lt;&lt; 23 | tail; //符号位 exp frac 或运算</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题目：将int型的x转为float型的x<br>P82页的整数转浮点数还有P83页的向偶数舍入。<br>基本思路：判断是 规则化 还是 非规则化 的 -&gt; 记录正负 -&gt;记录frac部分的长度和大小 -&gt; 求exp的值 -&gt;三个部分或运算</p>
<h3 id="15-float-twice"><a href="#15-float-twice" class="headerlink" title="15.float_twice"></a>15.float_twice</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line">* float_twice - Return bit-level equivalent of expression 2*f for </span><br><span class="line">* floating point argument f. </span><br><span class="line">* Both the argument and result are passed as unsigned int&apos;s, but </span><br><span class="line">* they are to be interpreted as the bit-level representation of </span><br><span class="line">* single-precision floating point values. </span><br><span class="line">* When argument is NaN, return argument </span><br><span class="line">* Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while </span><br><span class="line">* Max ops: 30 * Rating: 4 </span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">unsigned float_twice(unsigned uf) &#123;</span><br><span class="line">    /* if its denormalized double fraction, if its normailized, increase</span><br><span class="line">     * exponent, if it on the edege, decrement fraction, increment epx. */</span><br><span class="line">    unsigned expn = (uf &gt;&gt; 23) &amp; 0xFF;</span><br><span class="line">    unsigned sign = uf &amp; 0x80000000;</span><br><span class="line">    unsigned frac = uf &amp; 0x007FFFFF;</span><br><span class="line">    if (expn == 255 || (expn == 0 &amp;&amp; frac == 0))</span><br><span class="line">        return uf;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if (expn) &#123;</span><br><span class="line">        expn++;</span><br><span class="line">    &#125; else if (frac == 0x7FFFFF) </span><br><span class="line">&#123;</span><br><span class="line">        expn++;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        frac &lt;&lt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    return (sign) | (expn &lt;&lt; 23) | (frac);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>题目：就是将浮点数乘以2倍。<br>想法：按照浮点数想法先把浮点数拆成s(1位)E(8位)M(23位)，然后我们先把inf和NAN情况（ 无穷大和NaN，乘2也是返回uf本身）去除之后，当E是0时M&lt;&lt;1。当M是0时E&lt;&lt;1，最后将3个部分加起来。</p>

  </section>

  <section class="post-comments">

    <!-- 将评论系统（例如Disqus、多说、友言、畅言等）提供的代码片段粘贴在这里 -->
    
</section>


</article>


            <footer class="footer">

    <span class="footer__copyright">&copy; 2014-2015. | 由<a href="https://hexo.io/">Hexo</a>强力驱动 | 主题<a href="https://github.com/someus/huno">Huno</a></span>
    
</footer>
        </div>
    </div>

    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>
    

    

    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript"> 
        $(document).ready(function(){
            MathJax.Hub.Config({ 
                tex2jax: {inlineMath: [['[latex]','[/latex]'], ['\\(','\\)']]} 
            });
        });
    </script>


    

    <script src="/js/jquery.min.js"></script>
    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    
    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

</body>
</html>
